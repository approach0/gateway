user root root;
worker_processes 1;
error_log stderr notice;

events {
	worker_connections 1024;
}

http {
	include /etc/openresty/mime.types;
	access_log logs/access.log;
	resolver 127.0.0.11 valid=30s ipv6=off;
	# define rate-limit zones
	limit_req_zone $binary_remote_addr zone=slow:10m rate=128r/m;
	limit_req_zone $binary_remote_addr zone=high:10m rate=256r/m;

	lua_socket_log_errors on;
	# Service discovery and protection
	lua_shared_dict route_map 8m;
	lua_shared_dict route_rrb 8m;
	lua_shared_dict protected 8m;
	# Prometheus metrics
	lua_shared_dict metrics 10m;
	# global JWT secret
	lua_shared_dict JWT 1m;

	init_worker_by_lua_file ./conf/init.lua;

	server {
		# nothing but a redirection from HTTPS to HTTP
		listen 80 default_server;
		return 301 https://$host$request_uri;
	}

	server {
		# burst: allow sequential packets in a short time frame.
		# here the number represents the queue size for a burst.
		limit_req zone=high burst=256 nodelay;
		limit_req_status 503;

		# expose http by default, use docker entrypoint to
		# automatically delete, uncomment below and switch to https.
		listen 443 default_server; # DELETE_THIS
		listen [::]:443 default_server; # DELETE_THIS
		# UNCOMMENT_THIS listen 443 ssl default_server;
		# UNCOMMENT_THIS listen [::]:443 ssl default_server;
		# UNCOMMENT_THIS ssl_certificate /root/cert.pem;
		# UNCOMMENT_THIS ssl_certificate_key /root/key.pem;

		server_name  _;

		# record real remote information such as IP address
		proxy_set_header Host $host;
		proxy_http_version 1.1;
		proxy_set_header Upgrade $http_upgrade;
		proxy_set_header Connection $http_connection;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Real-Port $remote_port;
		proxy_set_header X-Forwarded-Proto $scheme;
		proxy_cache off;
		proxy_redirect off;

		# geoIP information variables
		set $geo_city '';
		set $geo_ctry '';
		set $geo_longitude '';
		set $geo_latitude  '';

		location / {
			set $service_addr '';
			set $service_route '_root_';
			set $modified_uri '/'; # placeholder
			access_by_lua_file ./conf/rewrite.lua;

			proxy_pass http://$service_addr;
		}

		location ^~ /.well-known/ {
			default_type text/plain;
			root /root;
		}

		log_by_lua_block {
			metric_request_uri:inc(1, {ngx.var.uri, ngx.var.status})

			metric_request_geoip:inc(1, {
				ngx.var.remote_addr or 'private',
				ngx.var.geo_city or 'Unknown',
				ngx.var.geo_ctry or 'Unknown',
				ngx.var.geo_longitude or 'Unknown',
				ngx.var.geo_latitude or 'Unknown'
			})

			metric_response_bytes:inc(tonumber(ngx.var.bytes_sent), {ngx.var.uri})

			metric_request_timecost:inc(tonumber(ngx.var.request_time), {ngx.var.uri})
		}

		location = /metrics {
			content_by_lua_block {
				local json, err = unixsock_get('unix:/var/run/docker.sock', '/services')
				if err then
					metric_swarm_services:set(0, {"number"})
				else
					local j = cjson.decode(json)
					metric_swarm_services:set(#j, {"number"})
				end

				local json, err = unixsock_get('unix:/var/run/docker.sock', '/nodes')
				if err then
					metric_swarm_nodes:set(0, {"number"})
				else
					local j = cjson.decode(json)
					metric_swarm_nodes:set(#j, {"number"})
				end

				metric_connections:set(ngx.var.connections_active,  {"active"})
				metric_connections:set(ngx.var.connections_reading, {"reading"})
				metric_connections:set(ngx.var.connections_waiting, {"waiting"})
				metric_connections:set(ngx.var.connections_writing, {"writing"})
				prometheus:collect()
			}
		}

		location = /geolookup {
			content_by_lua_block {
				local ip = ngx.var.arg_ip or ngx.var.remote_addr
				local success, info = geo_lookup(ip)
				if success then
					ngx.print(cjson.encode(info))
					ngx.exit(ngx.HTTP_OK)
				else
					ngx.print(ip, ': ', info)
					ngx.exit(ngx.HTTP_OK)
				end
			}
		}

		location = /services {
			limit_except GET {deny  all;}
			proxy_pass http://unix:/var/run/docker.sock:/services;
		}
		location = /nodes {
			limit_except GET {deny  all;}
			proxy_pass http://unix:/var/run/docker.sock:/nodes;
		}

		location ~ ^/([^/]+)(.*) {
			set $service_addr '';
			set $service_route $1;
			set $modified_uri $2;
			access_by_lua_file ./conf/rewrite.lua;

			proxy_pass http://$service_addr$modified_uri$is_args$args;
		}
	}
}
